2022년 5월 18일 수요일


# 알고리즘

- Quick Sort [퀵 정렬]
    - 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 부분리스트로 나누어 하나는 피벗보다 작은 값들의 부분리스트, 다른 하나는 피벗보다 큰 값들의 부분리스트로 정렬한 다음, 각 부분리스트에 대해 다시 위 처럼 재귀적으로 수행하여 정렬하는 방법
    - 분할 정복(Divide and Conquer)
    - 비교 정렬
    - 데이터 외에 추가적인 공간을 필요로 하지 않는다. 제자리 정렬(in-place sort)
    - 불안정정렬(Unstable Sort)
    - 시간복잡도는 O(n log n)

- Merge Sort [합병/병합 정렬]
    - 문제를 분할하고, 분할한 문제를 정복하여 합치는 알고리즘
    - 분할 정복(Divide and Conquer)
    - 비교 정렬
    - 데이터 외에 추가적인 공간을 필요로 하기 때문에 제자리 정렬(in-place sort)이 아니다.
    - 구조상 최대한 작게 문제를 쪼개어 앞의 부분리스트부터 차례대로 합쳐나가기 때문에 안정정렬(Stable Sort)
    - 장점
        - 항상 두 부분리스트로 쪼개어 들어가기 때문에 최악의 경우에도 O(NlogN) 으로 유지가 된다.
        - 안정정렬이다.
    - 단정
        - 정렬과정에서 추가적인 보조 배열 공간을 사용하기 때문에 메모리 사용량이 많다.
        - 보조 배열에서 원본배열로 복사하는 과정은 매우 많은 시간을 소비하기 때문에 데이터가 많을경우 상대적으로 시간이 많이 소요된다.
    - 시간 복잡도 O(NlogN)


- 순차탐색
    - 탐색할 데이터가 모인 집합이 있으면 집합의 처음부터 끝까지 집합의 원소들을 비교하여 원하는 데이터를 찾는 알고리즘
    - 단방향으로 탐색을 진행하기 때문에 선형탐색(Linear Search)

- 이진탐색
    - 정렬된 배열 또는 리스트에 적합한 고속 탐색 방법
    - 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄인다.
    - 찾고자 하는 값이 속해있지 않은 부분은 전혀 고려할 필요가 없기 때문에, 매 단계에서 검색해야 할 리스트의 크기를 반으로 줄일 수 있다.
    - 이러한 방법을 반복적으로 사용해 탐색하는 방법이 이진 탐색이다.
    - 데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않고, 주로 고정된 데이터에 대한 탐색에 적합하다.
    - 시간 복잡도 'T = K * logN'으로 O(logN)


# JAVA SERVLET

- 쿠키(Cookie)
    - 브라우저가 설치된 컴퓨터에 저장
    - 브라우저가 살아있는 동안만 쿠키가 유지
- 세션
    - 상태정보를 서버에 저장
    - 브라우저마다 고유한 세션 객체가 유지
    - 브라우저 하나당 서버 메모리에 하나씩 생성
    - 브라우저를 종료하면 세션도 종료
