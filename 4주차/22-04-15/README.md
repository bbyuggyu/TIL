2022년 4월 15일 금요일


# AOP: 컴퓨터 공학 필수

- Object 클래스
    - java.lang 패키지
        - 프로그래밍시 import 하지 않아도 자동으로 imort됨
        - String, Integer, System...
        - 기본 클래스들이 속한 패키지
    - java.lang.Object 클래스
    - 모든 클래스는 Object에서 상속받고, Object 클래스의 메서드 중 일부는 재정의해서 사용할 수 있음
    - 컴파일러가 extends Object를 추가함

- toString() 메서드
    - 객체의 정보를 String으로 바꾸어서 사용할 때 쓰임
    - String이나 Integer 클래스는 이미 재정의 되어 있음
    - 재정의 하여 사용

- equals() 메서드
    - 두 인스턴스의 주소 값을 비교하여 true/false를 반환
    - 재정의 하여 두 인스턴스가 논리적으로 동일함의 여부를 구현함
    - 인스턴스가 다르더라도 논리적으로 동일한 경우 true를 반환하도록 재정의 할 수 있음

- hashCode() 메서드
    - hashCode()는 인스턴스의 저장 주소를 반환함
    - 힙메모리에 인스턴스가 저장되는 방식이 hash 방식
    - hash : 정보를 저장, 검색하는 자료구조
    - 자료의 특정 값(키 값)에 대한 저장 위치를 반환해주는 해시 함수를 사용
    - 리적으로 동일함을 위해 equals() 메서드를 재정의 하였다면 hashCode()메서드도 재정의 하여 동일한 hashCode 값이 반환되도록 한다

- clone() 메서드
    - 객체의 원본을 복제하는데 사용하는 메서드
    - 생성과정의 복잡한 과정을 반복하지 않고 복제 할 수 있음
    - clone()메서드를 사용하면 객체의 정보(멤버 변수 값등...)가 동일한 또 다른 인스턴스가 생성되는 것이므로, 객체 지향 프로그램에서의 정보 은닉, 객체 보호의 관점에서 위배될 수 있음
    - 해당 클래스의 clone() 메서드의 사용을 허용한다는 의미로 cloneable 인터페이스를 명시해 줌

- String 클래스
    - 힙 메모리에 인스턴스로 생성되는 경우와 상수 풀(constant pool)에 있는 주소를 참조하는 두 가지 방법
    - 힙 메모리는 생성될때마다 다른 주소 값을 가지지만, 상수 풀의 문자열은 모두 같은 주소 값을 가짐
    - 한번 생성된 String은 불변(immutable)
    - String을 연결하면 기존의 String에 연결되는 것이 아닌 새로운 문자열이 생성됨 ( 메모리 낭비가 발생할 수도 )
        - StringBuilder, StringBuffer
            - 내부적으로 가변적인 char[]를 멤버 변수로 가짐
            - 문자열을 여러번 연결하거나 변경할 때 사용하면 유용함
            - 새로운 인스턴스를 생성하지 않고 char[] 를 변경함
            - StringBuffer는 멀티 쓰레드 프로그래밍에서 동기화(synchronization)을 보장
            - 단인 쓰레드 프로그램에서는 StringBuilder 사용을 권장
            - toString() 메서드로 String반환

- text block
    - 문자열을 """ """ 사이에 이어서 만들 수 있음
    - html, json 문자열을 만드는데 유용하게 사용할 수 있음

- Class 클래스
    - 자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일이 생성됨
    - Class 클래스는 컴파일 된 class 파일을 로드하여 객체를 동적 로드하고, 정보를 가져오는 메서드가 제공됨
    - 일반적으로 자료형을 알고 있는 경우엔 사용하지 않음
    - 필요할 때 공부할 것

- 자료구조
    - 프로그램에서 사용할 많은 데이타를 메모리 상에서 관리하는 여러 구현방법들
    - 효율적인 자료구조가 성능 좋은 알고리즘의 기반이 됨
    - 자료의 효율적인 관리는 프로그램의 수행속도와 밀접한 관련이 있음
    - 여러 자료 구조 중에서 구현하려는 프로그램에 맞는 최적의 자료구조를 활용해야 하므로 자료구조에 대한 이해가 중요함

    - 선형 자료구조
        - 배열 (Array)  : 선형으로 자료를 관리, 정해진 크기의 메모리를 먼저 할당받아 사용하고, 자료의 물리적 위치와 논리적 위치가 같음
        - 연결 리스트 (LinkedList) : 선형으로 자료를 관리, 자료가 추가될 때마다 메모리를 할당 받고, 자료는 링크로 연결됨. 자료의 물리적 위치와 논리적 위치가 다를 수 있음
        - 스택 (Stack) : 가장 나중에 입력 된 자료가 가장 먼저 출력되는 자료 구조 (Last In First OUt)
        - 큐 (Queue) :  가장 먼저 입력 된 자료가 가장 먼저 출력되는 자료 구조 (First In First Out)
        - 트리 (Tree) : 부모 노드와 자식 노드간의 연결로 이루어진 자료 구조
        - 힙(heap) : Priority queue를 구현 (우선 큐)
            - Max heap : 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우
            - Min heap : 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우
        - 이진 트리 (binary tree) : 부모노드에 자식노드가 두 개 이하인 트리
        - 이진 검색 트리 (binary search tree)
            - 자료(key)의 중복을 허용하지 않음
            - 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가짐
            - 자료를 검색에 걸리는 시간이 평균 log(n) 임
            - inorder traversal 탐색을 하게 되면 자료가 정렬되어 출력됨 
        - 그래프 (Graph) :  정점과 간선들의 유한 집합 G = (V,E)
            - 정점(vertex) : 여러 특성을 가지는 객체, 노드(node)
            - 간선(edge) : 이 객체들을 연결 관계를 나타냄. 링크(link)
            - 간선은 방향성이 있는 경우와 없는 경우가 있음
            - 그래프를 구현하는 방법 : 인접 행렬(adjacency matrix), 인접 리스트(adjacency list)
            - 그래프를 탐색하는 방법 : BFS(bread first search), DFS(depth first search)
        - 해싱 (Hashing) : 자료를 검색하기 위한 자료 구조
            - 검색을 위한 자료 구조
            - 키(key)에 대한 자료를 검색하기 위한 사전(dictionary) 개념의 자료 구조
            - key는 유일하고 이에 대한 value를 쌍으로 저장
            - index = h(key) : 해시 함수가 key에 대한 인덱스를 반환해줌 해당 인덱스 위치에 자료를 저장하거나 검색하게 됨
            - 해시 함수에 의해 인덱스 연산이 산술적으로 가능 O(1)
            - 저장되는 메모리 구조를 해시테이블이라 함
            - jdk 클래스 : HashMap, Properties
            - 해시테이블
            - 체이닝

- 배열(Array)
    - 동일한 데이터 타입을 순서에 따라 관리하는 자료 구조
    - 정해진 크기가 있음
    - 요소의 추가와 제거시 다른 요소들의 이동이 필요함
    - 배열의 i 번째 요소를 찾는 인덱스 연산이 빠름
    - jdk 클래스 : ArrayList, Vector

- 연결 리스트 (LinkedList)
    - 동일한 데이터 타입을 순서에 따라 관리하는 자료 구조
    - 자료를 저장하는 노드에는 자료와 다음 요소를 가리키는 링크(포인터)가 있음
    - 자료가 추가 될때 노드 만큼의 메모리를 할당 받고 이전 노드의 링크로 연결함 (정해진 크기가 없음)
    - 연결 리스트의 i 번째 요소를 찾는게 걸리는 시간은 요소의 개수에 비례 : O(n)
    - jdk 클래스 : LinkedList

- 스택(Stack)
    - 맨 마지막 위치(top)에서만 자료를 추가,삭제, 꺼내올 수 있음 ( 중간의 자료를 꺼낼 수 없음)
    - Last In First Out ( 후입선출 ) 구조
    - 택배 상자가 쌓여있는 모양
    - 가장 최근의 자료를 찾아오거나 게임에서 히스토리를 유지하고 이를 무를때 사용할 수 있음
    - 함수의 메모리는 호출 순서에 따른 stack 구조
    - jdk 클래스 : Stack

- 큐(Queue)
    - 맨 앞(front) 에서 자료를 꺼내거나 삭제하고, 맨 뒤(rear)에서 자료를 추가 함
    - Fist In First Out (선입선출) 구조
    - 일상 생활에서 일렬로 줄 서 있는 모양
    - 순차적으로 입력된 자료를 순서대로 처리하는데 많이 사용 되는 자료구조
    - 콜센터에 들어온 문의 전화, 메세지 큐 등에 활용됨
    - jdk 클래스 : ArrayList

- 제네릭 
    - 클래스에서 사용하는 변수의 자료형이 여러개 일수 있고, 그 기능(메서드)은 동일한 경우 클래스의 자료형을 특정하지 않고
    추후 해당 클래스를 사용할 때 지정 할 수 있도록 선언
    - 실제 사용되는 자료형의 변환은 컴파일러에 의해 검증되므로 안정적인 프로그래밍 방식
    - 컬렉션 프레임워크에서 많이 사용되고 있음
    - T extends 클래스
        - T 자료형의 범위를 제한 할 수 있음
        - 상위 클래스에서 선언하거나 정의하는 메서드를 활용할 수 있음
        - 상속을 받지 않는 경우 T는 Object로 변환되어 Object 클래스가 기본으로 제공하는 메서드만 사용가능
    - 제네릭 메서드
        - 자료형 매개변수를 메서드의 매개변수나 반환 값으로 가지는 메서드
        - 자료형 매개 변수가 하나 이상인 경우도 있음
        - 제네릭 클래스가 아니어도 내부에 제네릭 메서드는 구현하여 사용 할 수 있음
        - public <자료형 매개 변수> 반환형 메서드 이름(자료형 매개변수.....) { }

- 컬렉션 프레임워크
    - 프로그램 구현에 필요한 자료구조(Data Structure)를 구현해 놓은 JDK 라이브러리
    - java.util 패키지에 구현되어 있음
    - 개발에 소요되는 시간을 절약하면서 최적화 된 알고리즘을 사용할 수 있음
    - 여러 구현 클래스와 인터페이스의 활용에 대한 이해가 필요함

    - Collection
        - List 인터페이스
            - 객체를 순서에 따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스
            - 자료구조 리스트 (배열, 연결리스트)의 구현을 위한 인터페이스
            - 중복을 허용함
            - ArrayList, Vector, LinkedList, Stack, Queue 등...
        - Set 인터페이스
            - 순서와 관계없이 중복을 허용하지 않고 유일한 값을 관리하는데 필요한 메서드가 선언됨
            - 아이디, 주민번호, 사번등을 관리하는데 유용
            - 저장된 순서와 출력되는 순서는 다를 수 있음
            - HashSet, TreeSet등...
    - Map 인터페이스
        - 쌍(pair)로 이루어진 객체를 관리하는데 사용하는 메서드들이 선언된 인터페이스
        - 객체는 key-value의 쌍으로 이루어짐
        - key는 중복을 허용하지 않음
        - HashTable, HashMap, Properties, TreeMap 등이 Map 인터페이스를 구현 함
    
    - ArrayList

    - Collection 요소를 순회하는 Iterator
        - 컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조하는것
        - 순서가 있는 List인터페이스의 경우는 Iterator를 사용 하지 않고 get(i) 메서드를 활용할 수 있음
        - Set 인터페이스의 경우 get(i) 메서드가 제공되지 않으므로 Iterator를 활용하여 객체를 순회함
        - boolean hasNext() : 이후에 요소가 더 있는지를 체크하는 메서드, 요소가 있다면 true를 반환
        - E next() : 다음에 있는 요소를 반환

    - HashSet 클래스
        - Set 인터페이스를 구현한 클래스
        - 멤버의 중복 여부를 체크하기 위해 인스턴스의 동일성을 확인해야 함
        - 동일성 구현을 위해 필요에 따라 equals()와 hashCode()메서드를 재정의함
    - TreeSet 클래스
        - 객체의 정렬에 사용하는 클래스
        - Set 인터페이스를 구현하여 중복을 허용하지 않고, 오름차순이나 내림차순으로 객체를 정렬할 수 있음
        - 내부적으로 이진검색트리(binary search tree)로 구현됨
        - 이진검색트리에 저장하기 위해 각 객체를 비교해야 함
        - 비교 대상이 되는 객체에 Comparable이나 Comparator 인터페이스를 구현 해야 TreeSet에 추가 될 수 있음 (주로 Comparable 사용)
        - String, Integer등 JDK의 많은 클래스들이 이미 Comparable을 구현했음
        - implements Comparable<>
    
    - HashMap 클래스
        - Map 인터페이스를 구현한 클래스와
        - 가장 많이 사용되는 Map 인터페이스 기반 클래스
        - key - value를 쌍으로 관리하는 메서드를 구현함
        - 검색을 위한 자료구조
        - key를 이용하여 값을 저정하고 key를 이용하여 값을 꺼내오는 방식 - hash 알고리즘으로 구현 됨
        - key가 되는 객체는 중복될 수 없고 객체의 유일성을 비교를 위한 equals()와 hashCode() 메서드를 구현해야 함
    - TreeMap 클래스
        - Map 인터페이스를 구현한 클래스이고 key에 대한 정렬을 구현할 수 있음
        - key가 되는 클래스에 Comparable이나 Comparator인터페이스를 구현함으로써 key-value 쌍의 자료를 key값 기준으로 정렬하여 관리 할 수 있음

