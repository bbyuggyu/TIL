2022년 4월 13일 수요일


# 권장강의

- 객체
- 클래스


# AOP: 백엔드 개발 필수

- 상속
    - 새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속(inheritance) 받아서 속성이나 기능을 확장하여 클래스를 구현함
    - 이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 기존 클래스를 상속함
    - 상속 문법 ```class B extends A{}```
    - 상위 클래스는 하위 클래스 보다 더 일반적인 개념과 기능을 가짐
    - 하위 클래스는 상위 클래스 보다 더 구체적인 개념과 기능을 가짐
    - 하위 클래스가 상위 클래스의 속성과 기능을 확장 (extends)한다는 의미
    - 하위 클래스를 생성하면 상위 클래스가 먼저 생성 됨
    - 클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출 함
    - super 
        - 하위 클래스에서 가지는 상위 클래스에 대한 참조 값
        - super()는 상위 클래스의 기본 생성자를 호출 함
        - 하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출 됨  
        ( 이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
        - 상위 클래스의 기본 생성자가 없는 경우 ( 다른 생성자가 있는 경우 ) 하위 클래스에서는 생성자에서는 super를 이용하여  
        명시적으로 상위 클래스의 생성자를 호출 함
        - super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 있음
    - 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성
    - 하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환이 가능함
    - 상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)이 됨
    - overring
        - 오버라이딩(overriding) : 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우  
        하위 클래스에서 동일한 이름의 메서드를 재정의 할 수 있음
        - 재정의 하여 구현해야 함
        - @overriding 애노테이션 (annotation)

- 메서드
    - 메서드(함수)의 이름은 주소값을 나타냄
    - 메서드는 명령어의 set 이고 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치
    - 해당 메서드가 호출 되면 명령어 set 이 있는 주소를 찾아 명령어가 실행됨
    - 이때 메서드에서 사용하는 변수들은 스택 메모리에 위치 하게됨
    - 따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨
    - 인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드 됨
- 가상 메서드
    - 가상 메서드 테이블(vitual method table)에서 해당 메서드에 대한 address를 가지고 있음
    - 재정의된 경우는 재정의 된 메서드의 주소를 가리킴

- 다형성
    - 하나의 코드가 여러 자료형으로 구현되어 실행되는 것
    - 같은 코드에서 여러 다른 실행 결과가 나옴
    - 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나임
    - 다형성을 잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있음
    - 상속과 메서드 재정의를 활용하여 확장성 있는 프로그램을 만들 수 있음, 그렇지 않는 경우 많은 if-else if문이 구현되고 코드의 유지보수가 어려워짐
    - 상위 클래스에서는 공통적인 부분을 제공하고 하위 클래스에서는 각 클래스에 맞는 기능 구현
    - 여러 클래스를 하나의 타입(상위 클래스)으로 핸들링 할 수 있음

- 다운 캐스팅(downcasting)
    - 업캐스팅된 클래스를 다시 원래의 타입으로 형 변환
    - 하위 클래스로의 형 변환은 명시적으로 해야 함

- 추상 클래스
    - 구현 코드 없이 메서드의 선언만 있는 추상 메서드(abstract method)를 포함한 클래스
    - 메서드 선언(declaration) : 반환타입, 메서드 이름, 매개변수로 구성
    - 메서드 정의(definition) : 메서드 구현(implementation)과 동일한 의미 구현부(body) 를 가짐 ({ })
    예) int add(int x, int y); // 선언  
    int add(int x, int y){ } // 구현부가 있음, 추상 메서드 아님
    - abstract 예약어를 사용
    - 추상 클래스는 new 할 수 없음 ( 인스턴스화 할 수 없음 )

- 템플릿 메서드
    - 추상 메서드나 구현 된 메서드를 활용하여 코드의 흐름(시나리오)를 정의하는 메서드
    - final로 선언하여 하위 클래스에서 재정의 할 수 없게 함
    - 프레임워크에서 많이 사용되는 설계 패턴
    - 추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용하여 전체적인 흐름을 정의 하고 하위 클래스에서  
    다르게 구현되어야 하는 부분은 추상 메서드로 선언하여 하위 클래스에서 구현 하도록 함

- final
    - final 변수 : 값이 변경될 수 없는 상수
    - final 메서드 : 하위 클래스에서 재정의 할 수 없는 메서드
    - final 클래스 : 상속할 수 없는 클래스


# JAVA 프로그래밍 심화

- 모든 예외에 최상위는 Exception

- java.lang
    - import가 필요 없음
    - Object 최상위 부모 클래스
    - equals()
    - toString()
    - String 
        - equals()
        - concat()
        - toString()
        - length()
        - indexOf()
        - substring()
        - split()
    - StringBuffer 
        - 가변 길이 문자열을 제공 (같은 주소 공유)
    - 래퍼(Wrapper)
        - Integer.parseInt

- java.util
    - java.util.Random
    - java.util.Arrays
        - copyOf
        - sort
    - java.util.Date
    - java.util.Calendar

- 자바의 컬렉션
    - java.util.List
        - add
        - get
        - size
        - 제네릭
    - java.util.Set
    - Set과 List의 차이점은 데이터의 순서가 정해져 있지 않다는 것과 데이터가 중복 되지 않음
    - java.util.Map
        - 키(Key), 밸류(Value)
        - set, Collection
        - put

    
